export default class{static parse(e,t,r=(e=>e)){const a=Object.create(null);a.options=t||{},a.reviver=r,a.value="",a.entry=[],a.output=[],a.col=1,a.row=1;const s=RegExp(/"|,|\r\n|\n|\r|[^",\r\n]+/y);let o=[],n="",c=0;for(;null!==(o=s.exec(e));)switch(n=o[0],c){case 0:switch(!0){case'"'===n:c=3;break;case","===n:c=0,this.valueEnd(a);break;case/^(\r\n|\n|\r)$/.test(n):c=0,this.valueEnd(a),this.entryEnd(a);break;default:a.value+=n,c=2}break;case 2:switch(!0){case","===n:c=0,this.valueEnd(a);break;case/^(\r\n|\n|\r)$/.test(n):c=0,this.valueEnd(a),this.entryEnd(a);break;default:throw c=4,Error(`CSVError: Illegal state [row:${a.row}, col:${a.col}]`)}break;case 3:switch(!0){case'"'===n:c=4;break;default:c=3,a.value+=n}break;case 4:switch(!0){case'"'===n:c=3,a.value+=n;break;case","===n:c=0,this.valueEnd(a);break;case/^(\r\n|\n|\r)$/.test(n):c=0,this.valueEnd(a),this.entryEnd(a);break;default:throw Error(`CSVError: Illegal state [row:${a.row}, col:${a.col}]`)}}return 0!==a.entry.length&&(this.valueEnd(a),this.entryEnd(a)),a.output}static stringify(e,t={},r=(e=>e)){const a=Object.create(null);return a.options=t,a.options.eof=void 0===a.options.eof||a.options.eof,a.row=1,a.col=1,a.output="",e.forEach((t,s)=>{let o="";switch(a.col=1,t.forEach((e,s)=>{e=e.replace('"','""'),e=/"|,|\r\n|\n|\r/.test(e)?`"${e}"`:e,o+=r(e,a.row,a.col),s!==t.length-1&&(o+=","),a.col++}),!0){case a.options.eof:case!a.options.eof&&s!==e.length-1:a.output+=`${o}\n`;break;default:a.output+=`${o}`}a.row++}),a.output}static valueEnd(e){const t=e.options.typed?this.inferType(e.value):e.value;e.entry.push(e.reviver(t,e.row,e.col)),e.value="",e.col++}static entryEnd(e){e.output.push(e.entry),e.entry=[],e.row++,e.col=1}static inferType(e){switch(!0){case"true"===e:case"false"===e:return"true"===e;case/.\./.test(e):return parseFloat(e);case isFinite(e):return parseInt(e);default:return e}}}
