export default class{static parse(e,t,r=(e=>e)){let a=[],s="",o=0;const n=Object.create(null);n.options=t||{},n.reviver=r,n.value="",n.entry=[],n.output=[],n.col=1,n.row=1;const c=RegExp(/"|,|\r\n|\n|\r|[^",\r\n]+/y);for(;null!==(a=c.exec(e));)switch(s=a[0],o){case 0:switch(!0){case'"'===s:o=3;break;case","===s:o=0,this.valueEnd(n);break;case/^(\r\n|\n|\r)$/.test(s):o=0,this.valueEnd(n),this.entryEnd(n);break;default:n.value+=s,o=2}break;case 2:switch(!0){case","===s:o=0,this.valueEnd(n);break;case/^(\r\n|\n|\r)$/.test(s):o=0,this.valueEnd(n),this.entryEnd(n);break;default:throw o=4,Error(`CSVError: Illegal state [row:${n.row}, col:${n.col}]`)}break;case 3:switch(!0){case'"'===s:o=4;break;default:o=3,n.value+=s}break;case 4:switch(!0){case'"'===s:o=3,n.value+=s;break;case","===s:o=0,this.valueEnd(n);break;case/^(\r\n|\n|\r)$/.test(s):o=0,this.valueEnd(n),this.entryEnd(n);break;default:throw Error(`CSVError: Illegal state [row:${n.row}, col:${n.col}]`)}}return 0!==n.entry.length&&(this.valueEnd(n),this.entryEnd(n)),n.output}static stringify(e,t={},r=(e=>e)){const a=Object.create(null);return a.options=t,a.options.eof=void 0===a.options.eof||a.options.eof,a.row=1,a.col=1,a.output="",e.forEach((t,s)=>{let o="";switch(a.col=1,t.forEach((e,s)=>{e=e.replace('"','""'),e=/"|,|\r\n|\n|\r/.test(e)?`"${e}"`:e,o+=r(e,a.row,a.col),s!==t.length-1&&(o+=","),a.col++}),!0){case a.options.eof:case!a.options.eof&&s!==e.length-1:a.output+=`${o}\n`;break;default:a.output+=`${o}`}a.row++}),a.output}static valueEnd(e){const t=e.options.typed?this.inferType(e.value):e.value;e.entry.push(e.reviver(t,e.row,e.col)),e.value="",e.col++}static entryEnd(e){e.output.push(e.entry),e.entry=[],e.row++,e.col=1}static inferType(e){switch(!0){case"true"===e:case"false"===e:return"true"===e;case/.\./.test(e):return parseFloat(e);case isFinite(e):return parseInt(e);default:return e}}}
