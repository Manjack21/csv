function e(e,t,a=(e=>e)){const c=Object.create(null);c.options=t||{},c.reviver=a,c.value="",c.entry=[],c.output=[],c.col=1,c.row=1;const n=RegExp(/"|,|\r\n|\n|\r|[^",\r\n]+/y);let s=[],l="",u=0;for(;null!==(s=n.exec(e));)switch(l=s[0],u){case 0:switch(!0){case'"'===l:u=3;break;case","===l:u=0,r(c);break;case/^(\r\n|\n|\r)$/.test(l):u=0,r(c),o(c);break;default:c.value+=l,u=2}break;case 2:switch(!0){case","===l:u=0,r(c);break;case/^(\r\n|\n|\r)$/.test(l):u=0,r(c),o(c);break;default:throw u=4,Error(`CSVError: Illegal state [row:${c.row}, col:${c.col}]`)}break;case 3:switch(!0){case'"'===l:u=4;break;default:u=3,c.value+=l}break;case 4:switch(!0){case'"'===l:u=3,c.value+=l;break;case","===l:u=0,r(c);break;case/^(\r\n|\n|\r)$/.test(l):u=0,r(c),o(c);break;default:throw Error(`CSVError: Illegal state [row:${c.row}, col:${c.col}]`)}}return 0!==c.entry.length&&(r(c),o(c)),c.output}function t(e,t={},r=(e=>e)){const o=Object.create(null);return o.options=t,o.options.eof=void 0===o.options.eof||o.options.eof,o.row=1,o.col=1,o.output="",e.forEach((t,a)=>{let c="";switch(o.col=1,t.forEach((e,a)=>{"string"==typeof e&&(e=e.replace('"','""'),e=/"|,|\r\n|\n|\r/.test(e)?`"${e}"`:e),c+=r(e,o.row,o.col),a!==t.length-1&&(c+=","),o.col++}),!0){case o.options.eof:case!o.options.eof&&a!==e.length-1:o.output+=`${c}\n`;break;default:o.output+=`${c}`}o.row++}),o.output}function r(e){const t=e.options.typed?function(e){switch(!0){case"true"===e:case"false"===e:return"true"===e;case/.\./.test(e):return parseFloat(e);case isFinite(e):return parseInt(e);default:return e}}(e.value):e.value;e.entry.push(e.reviver(t,e.row,e.col)),e.value="",e.col++}function o(e){e.output.push(e.entry),e.entry=[],e.row++,e.col=1}var a={parse:e,stringify:t};export default a;export{e as parse,t as stringify};
