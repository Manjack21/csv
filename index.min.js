export default class{static parse(e,t,r=(e=>e)){let a=[],s="",n=0;const l=Object.create(null);l.options=t||{},l.reviver=r,l.value="",l.entry=[],l.output=[],l.col=1,l.row=1;const c=RegExp(/"|,|\r\n|\n|\r|[^",\r\n]+/y);for(;null!==(a=c.exec(e));)switch(s=a[0],n){case 0:switch(!0){case'"'===s:n=3;break;case","===s:n=0,this.valueEnd(l);break;case/^(\r\n|\n|\r)$/.test(s):n=0,this.valueEnd(l),this.entryEnd(l);break;default:l.value+=s,n=2}break;case 2:switch(!0){case","===s:n=0,this.valueEnd(l);break;case/^(\r\n|\n|\r)$/.test(s):n=0,this.valueEnd(l),this.entryEnd(l);break;default:throw n=4,Error(`CSVError: Illegal state [row:${l.row}, col:${l.col}]`)}break;case 3:switch(!0){case'"'===s:n=4;break;default:n=3,l.value+=s}break;case 4:switch(!0){case'"'===s:n=3,l.value+=s;break;case","===s:n=0,this.valueEnd(l);break;case/^(\r\n|\n|\r)$/.test(s):n=0,this.valueEnd(l),this.entryEnd(l);break;default:throw Error(`CSVError: Illegal state [row:${l.row}, col:${l.col}]`)}}return 0!==l.entry.length&&(this.valueEnd(l),this.entryEnd(l)),l.output}static stringify(e,t={},r=(e=>e)){t.eof=void 0===t.eof||t.eof;let a="";return e.forEach((r,s)=>{let n="";r.forEach((e,t)=>{e=e.replace('"','""'),n+=/"|,|\r\n|\n|\r/.test(e)?`"${e}"`:e,t!==r.length-1&&(n+=",")}),!1===t.eof?(a+=n,s!==e.length-1&&(a+="\n")):a+=`${n}\n`}),a}static valueEnd(e){const t=e.options.typed?this.inferType(e.value):e.value;e.entry.push(e.reviver(t,e.row,e.col)),e.value="",e.col++}static entryEnd(e){e.output.push(e.entry),e.entry=[],e.row++,e.col=1}static inferType(e){switch(!0){case"true"===e:case"false"===e:return"true"===e;case/.\./.test(e):return parseFloat(e);case isFinite(e):return parseInt(e);default:return e}}}
